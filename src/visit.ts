/** Generated **/
import { SyntaxKind } from "typescript";  
import type * as AST from "./types.ts";

type AnyNode = AST.ArrayBindingPattern | AST.ArrayLiteralExpression | AST.ArrayTypeNode | AST.ArrowFunction | AST.AsExpression | AST.AwaitExpression | AST.BigIntLiteral | AST.BinaryExpression | AST.BindingElement | AST.Block | AST.BreakStatement | AST.CallExpression | AST.CallSignatureDeclaration | AST.CaseBlock | AST.CaseClause | AST.CatchClause | AST.ClassDeclaration | AST.ClassExpression | AST.ClassStaticBlockDeclaration | AST.CommaListExpression | AST.ComputedPropertyName | AST.ConditionalExpression | AST.ConditionalTypeNode | AST.ConstructSignatureDeclaration | AST.ConstructorDeclaration | AST.ConstructorTypeNode | AST.ContinueStatement | AST.DebuggerStatement | AST.Decorator | AST.DefaultClause | AST.DeleteExpression | AST.DoStatement | AST.ElementAccessExpression | AST.EmptyStatement | AST.EnumDeclaration | AST.EnumMember | AST.ExportAssignment | AST.ExportDeclaration | AST.ExportSpecifier | AST.ExpressionStatement | AST.ExpressionWithTypeArguments | AST.ExternalModuleReference | AST.FalseLiteral | AST.ForInStatement | AST.ForOfStatement | AST.ForStatement | AST.FunctionDeclaration | AST.FunctionExpression | AST.FunctionTypeNode | AST.GetAccessorDeclaration | AST.HeritageClause | AST.Identifier | AST.IfStatement | AST.ImportAttribute | AST.ImportAttributes | AST.ImportClause | AST.ImportDeclaration | AST.ImportEqualsDeclaration | AST.ImportExpression | AST.ImportSpecifier | AST.ImportTypeNode | AST.IndexSignatureDeclaration | AST.IndexedAccessTypeNode | AST.InferTypeNode | AST.InterfaceDeclaration | AST.IntersectionTypeNode | AST.JSDocAllType | AST.JSDocFunctionType | AST.JSDocLink | AST.JSDocLinkCode | AST.JSDocLinkPlain | AST.JSDocMemberName | AST.JSDocNamepathType | AST.JSDocNonNullableType | AST.JSDocNullableType | AST.JSDocOptionalType | AST.JSDocParameterTag | AST.JSDocPropertyTag | AST.JSDocReturnTag | AST.JSDocSignature | AST.JSDocTemplateTag | AST.JSDocText | AST.JSDocTypeExpression | AST.JSDocTypeLiteral | AST.JSDocUnknownType | AST.JSDocVariadicType | AST.JsxAttribute | AST.JsxAttributes | AST.JsxClosingElement | AST.JsxClosingFragment | AST.JsxElement | AST.JsxExpression | AST.JsxFragment | AST.JsxNamespacedName | AST.JsxOpeningElement | AST.JsxOpeningFragment | AST.JsxSelfClosingElement | AST.JsxSpreadAttribute | AST.JsxText | AST.LabeledStatement | AST.LiteralTypeNode | AST.MappedTypeNode | AST.MetaProperty | AST.MethodDeclaration | AST.MethodSignature | AST.MissingDeclaration | AST.ModuleBlock | AST.ModuleDeclaration | AST.NamedExports | AST.NamedImports | AST.NamedTupleMember | AST.NamespaceExport | AST.NamespaceExportDeclaration | AST.NamespaceImport | AST.NewExpression | AST.NoSubstitutionTemplateLiteral | AST.NonNullExpression | AST.NotEmittedStatement | AST.NullLiteral | AST.NumericLiteral | AST.ObjectBindingPattern | AST.ObjectLiteralExpression | AST.OmittedExpression | AST.OptionalTypeNode | AST.ParameterDeclaration | AST.ParenthesizedExpression | AST.ParenthesizedTypeNode | AST.PartiallyEmittedExpression | AST.PostfixUnaryExpression | AST.PrefixUnaryExpression | AST.PrivateIdentifier | AST.PropertyAccessExpression | AST.PropertyAssignment | AST.PropertyDeclaration | AST.PropertySignature | AST.QualifiedName | AST.RegularExpressionLiteral | AST.RestTypeNode | AST.ReturnStatement | AST.SatisfiesExpression | AST.SemicolonClassElement | AST.SetAccessorDeclaration | AST.ShorthandPropertyAssignment | AST.SourceFile | AST.SpreadAssignment | AST.SpreadElement | AST.StringLiteral | AST.SuperExpression | AST.SwitchStatement | AST.SyntheticExpression | AST.TaggedTemplateExpression | AST.TemplateExpression | AST.TemplateHead | AST.TemplateLiteralTypeNode | AST.TemplateLiteralTypeSpan | AST.TemplateMiddle | AST.TemplateSpan | AST.TemplateTail | AST.ThisExpression | AST.ThisTypeNode | AST.ThrowStatement | AST.TrueLiteral | AST.TryStatement | AST.TupleTypeNode | AST.TypeAliasDeclaration | AST.TypeAssertion | AST.TypeLiteralNode | AST.TypeOfExpression | AST.TypeOperatorNode | AST.TypeParameterDeclaration | AST.TypePredicateNode | AST.TypeQueryNode | AST.TypeReferenceNode | AST.UnionTypeNode | AST.VariableDeclaration | AST.VariableDeclarationList | AST.VariableStatement | AST.VoidExpression | AST.WhileStatement | AST.WithStatement | AST.YieldExpression;

export const visit = (node: AnyNode, visitor: AST.Visitor<unknown>, context: AST.Context<unknown>) => {
  switch(node.kind) {
    case SyntaxKind.ArrayBindingPattern: visitor.ArrayBindingPattern?.(node, context); break;
    case SyntaxKind.ArrayLiteralExpression: visitor.ArrayLiteralExpression?.(node, context); break;
    case SyntaxKind.ArrayType: visitor.ArrayTypeNode?.(node, context); break;
    case SyntaxKind.ArrowFunction: visitor.ArrowFunction?.(node, context); break;
    case SyntaxKind.AsExpression: visitor.AsExpression?.(node, context); break;
    case SyntaxKind.AwaitExpression: visitor.AwaitExpression?.(node, context); break;
    case SyntaxKind.BigIntLiteral: visitor.BigIntLiteral?.(node, context); break;
    case SyntaxKind.BinaryExpression: visitor.BinaryExpression?.(node, context); break;
    case SyntaxKind.BindingElement: visitor.BindingElement?.(node, context); break;
    case SyntaxKind.Block: visitor.Block?.(node, context); break;
    case SyntaxKind.BreakStatement: visitor.BreakStatement?.(node, context); break;
    case SyntaxKind.CallExpression: visitor.CallExpression?.(node, context); break;
    case SyntaxKind.CallSignature: visitor.CallSignatureDeclaration?.(node, context); break;
    case SyntaxKind.CaseBlock: visitor.CaseBlock?.(node, context); break;
    case SyntaxKind.CaseClause: visitor.CaseClause?.(node, context); break;
    case SyntaxKind.CatchClause: visitor.CatchClause?.(node, context); break;
    case SyntaxKind.ClassDeclaration: visitor.ClassDeclaration?.(node, context); break;
    case SyntaxKind.ClassExpression: visitor.ClassExpression?.(node, context); break;
    case SyntaxKind.ClassStaticBlockDeclaration: visitor.ClassStaticBlockDeclaration?.(node, context); break;
    case SyntaxKind.CommaListExpression: visitor.CommaListExpression?.(node, context); break;
    case SyntaxKind.ComputedPropertyName: visitor.ComputedPropertyName?.(node, context); break;
    case SyntaxKind.ConditionalExpression: visitor.ConditionalExpression?.(node, context); break;
    case SyntaxKind.ConditionalType: visitor.ConditionalTypeNode?.(node, context); break;
    case SyntaxKind.ConstructSignature: visitor.ConstructSignatureDeclaration?.(node, context); break;
    case SyntaxKind.Constructor: visitor.ConstructorDeclaration?.(node, context); break;
    case SyntaxKind.ConstructorType: visitor.ConstructorTypeNode?.(node, context); break;
    case SyntaxKind.ContinueStatement: visitor.ContinueStatement?.(node, context); break;
    case SyntaxKind.DebuggerStatement: visitor.DebuggerStatement?.(node, context); break;
    case SyntaxKind.Decorator: visitor.Decorator?.(node, context); break;
    case SyntaxKind.DefaultClause: visitor.DefaultClause?.(node, context); break;
    case SyntaxKind.DeleteExpression: visitor.DeleteExpression?.(node, context); break;
    case SyntaxKind.DoStatement: visitor.DoStatement?.(node, context); break;
    case SyntaxKind.ElementAccessExpression: visitor.ElementAccessExpression?.(node, context); break;
    case SyntaxKind.EmptyStatement: visitor.EmptyStatement?.(node, context); break;
    case SyntaxKind.EnumDeclaration: visitor.EnumDeclaration?.(node, context); break;
    case SyntaxKind.EnumMember: visitor.EnumMember?.(node, context); break;
    case SyntaxKind.ExportAssignment: visitor.ExportAssignment?.(node, context); break;
    case SyntaxKind.ExportDeclaration: visitor.ExportDeclaration?.(node, context); break;
    case SyntaxKind.ExportSpecifier: visitor.ExportSpecifier?.(node, context); break;
    case SyntaxKind.ExpressionStatement: visitor.ExpressionStatement?.(node, context); break;
    case SyntaxKind.ExpressionWithTypeArguments: visitor.ExpressionWithTypeArguments?.(node, context); break;
    case SyntaxKind.ExternalModuleReference: visitor.ExternalModuleReference?.(node, context); break;
    case SyntaxKind.FalseKeyword: visitor.FalseLiteral?.(node, context); break;
    case SyntaxKind.ForInStatement: visitor.ForInStatement?.(node, context); break;
    case SyntaxKind.ForOfStatement: visitor.ForOfStatement?.(node, context); break;
    case SyntaxKind.ForStatement: visitor.ForStatement?.(node, context); break;
    case SyntaxKind.FunctionDeclaration: visitor.FunctionDeclaration?.(node, context); break;
    case SyntaxKind.FunctionExpression: visitor.FunctionExpression?.(node, context); break;
    case SyntaxKind.FunctionType: visitor.FunctionTypeNode?.(node, context); break;
    case SyntaxKind.GetAccessor: visitor.GetAccessorDeclaration?.(node, context); break;
    case SyntaxKind.HeritageClause: visitor.HeritageClause?.(node, context); break;
    case SyntaxKind.Identifier: visitor.Identifier?.(node, context); break;
    case SyntaxKind.IfStatement: visitor.IfStatement?.(node, context); break;
    case SyntaxKind.ImportAttribute: visitor.ImportAttribute?.(node, context); break;
    case SyntaxKind.ImportAttributes: visitor.ImportAttributes?.(node, context); break;
    case SyntaxKind.ImportClause: visitor.ImportClause?.(node, context); break;
    case SyntaxKind.ImportDeclaration: visitor.ImportDeclaration?.(node, context); break;
    case SyntaxKind.ImportEqualsDeclaration: visitor.ImportEqualsDeclaration?.(node, context); break;
    case SyntaxKind.ImportKeyword: visitor.ImportExpression?.(node, context); break;
    case SyntaxKind.ImportSpecifier: visitor.ImportSpecifier?.(node, context); break;
    case SyntaxKind.ImportType: visitor.ImportTypeNode?.(node, context); break;
    case SyntaxKind.IndexSignature: visitor.IndexSignatureDeclaration?.(node, context); break;
    case SyntaxKind.IndexedAccessType: visitor.IndexedAccessTypeNode?.(node, context); break;
    case SyntaxKind.InferType: visitor.InferTypeNode?.(node, context); break;
    case SyntaxKind.InterfaceDeclaration: visitor.InterfaceDeclaration?.(node, context); break;
    case SyntaxKind.IntersectionType: visitor.IntersectionTypeNode?.(node, context); break;
    case SyntaxKind.JSDocAllType: visitor.JSDocAllType?.(node, context); break;
    case SyntaxKind.JSDocFunctionType: visitor.JSDocFunctionType?.(node, context); break;
    case SyntaxKind.JSDocLink: visitor.JSDocLink?.(node, context); break;
    case SyntaxKind.JSDocLinkCode: visitor.JSDocLinkCode?.(node, context); break;
    case SyntaxKind.JSDocLinkPlain: visitor.JSDocLinkPlain?.(node, context); break;
    case SyntaxKind.JSDocMemberName: visitor.JSDocMemberName?.(node, context); break;
    case SyntaxKind.JSDocNamepathType: visitor.JSDocNamepathType?.(node, context); break;
    case SyntaxKind.JSDocNonNullableType: visitor.JSDocNonNullableType?.(node, context); break;
    case SyntaxKind.JSDocNullableType: visitor.JSDocNullableType?.(node, context); break;
    case SyntaxKind.JSDocOptionalType: visitor.JSDocOptionalType?.(node, context); break;
    case SyntaxKind.JSDocParameterTag: visitor.JSDocParameterTag?.(node, context); break;
    case SyntaxKind.JSDocPropertyTag: visitor.JSDocPropertyTag?.(node, context); break;
    case SyntaxKind.JSDocReturnTag: visitor.JSDocReturnTag?.(node, context); break;
    case SyntaxKind.JSDocSignature: visitor.JSDocSignature?.(node, context); break;
    case SyntaxKind.JSDocTemplateTag: visitor.JSDocTemplateTag?.(node, context); break;
    case SyntaxKind.JSDocText: visitor.JSDocText?.(node, context); break;
    case SyntaxKind.JSDocTypeExpression: visitor.JSDocTypeExpression?.(node, context); break;
    case SyntaxKind.JSDocTypeLiteral: visitor.JSDocTypeLiteral?.(node, context); break;
    case SyntaxKind.JSDocUnknownType: visitor.JSDocUnknownType?.(node, context); break;
    case SyntaxKind.JSDocVariadicType: visitor.JSDocVariadicType?.(node, context); break;
    case SyntaxKind.JsxAttribute: visitor.JsxAttribute?.(node, context); break;
    case SyntaxKind.JsxAttributes: visitor.JsxAttributes?.(node, context); break;
    case SyntaxKind.JsxClosingElement: visitor.JsxClosingElement?.(node, context); break;
    case SyntaxKind.JsxClosingFragment: visitor.JsxClosingFragment?.(node, context); break;
    case SyntaxKind.JsxElement: visitor.JsxElement?.(node, context); break;
    case SyntaxKind.JsxExpression: visitor.JsxExpression?.(node, context); break;
    case SyntaxKind.JsxFragment: visitor.JsxFragment?.(node, context); break;
    case SyntaxKind.JsxNamespacedName: visitor.JsxNamespacedName?.(node, context); break;
    case SyntaxKind.JsxOpeningElement: visitor.JsxOpeningElement?.(node, context); break;
    case SyntaxKind.JsxOpeningFragment: visitor.JsxOpeningFragment?.(node, context); break;
    case SyntaxKind.JsxSelfClosingElement: visitor.JsxSelfClosingElement?.(node, context); break;
    case SyntaxKind.JsxSpreadAttribute: visitor.JsxSpreadAttribute?.(node, context); break;
    case SyntaxKind.JsxText: visitor.JsxText?.(node, context); break;
    case SyntaxKind.LabeledStatement: visitor.LabeledStatement?.(node, context); break;
    case SyntaxKind.LiteralType: visitor.LiteralTypeNode?.(node, context); break;
    case SyntaxKind.MappedType: visitor.MappedTypeNode?.(node, context); break;
    case SyntaxKind.MetaProperty: visitor.MetaProperty?.(node, context); break;
    case SyntaxKind.MethodDeclaration: visitor.MethodDeclaration?.(node, context); break;
    case SyntaxKind.MethodSignature: visitor.MethodSignature?.(node, context); break;
    case SyntaxKind.MissingDeclaration: visitor.MissingDeclaration?.(node, context); break;
    case SyntaxKind.ModuleBlock: visitor.ModuleBlock?.(node, context); break;
    case SyntaxKind.ModuleDeclaration: visitor.ModuleDeclaration?.(node, context); break;
    case SyntaxKind.NamedExports: visitor.NamedExports?.(node, context); break;
    case SyntaxKind.NamedImports: visitor.NamedImports?.(node, context); break;
    case SyntaxKind.NamedTupleMember: visitor.NamedTupleMember?.(node, context); break;
    case SyntaxKind.NamespaceExport: visitor.NamespaceExport?.(node, context); break;
    case SyntaxKind.NamespaceExportDeclaration: visitor.NamespaceExportDeclaration?.(node, context); break;
    case SyntaxKind.NamespaceImport: visitor.NamespaceImport?.(node, context); break;
    case SyntaxKind.NewExpression: visitor.NewExpression?.(node, context); break;
    case SyntaxKind.NoSubstitutionTemplateLiteral: visitor.NoSubstitutionTemplateLiteral?.(node, context); break;
    case SyntaxKind.NonNullExpression: visitor.NonNullExpression?.(node, context); break;
    case SyntaxKind.NotEmittedStatement: visitor.NotEmittedStatement?.(node, context); break;
    case SyntaxKind.NullKeyword: visitor.NullLiteral?.(node, context); break;
    case SyntaxKind.NumericLiteral: visitor.NumericLiteral?.(node, context); break;
    case SyntaxKind.ObjectBindingPattern: visitor.ObjectBindingPattern?.(node, context); break;
    case SyntaxKind.ObjectLiteralExpression: visitor.ObjectLiteralExpression?.(node, context); break;
    case SyntaxKind.OmittedExpression: visitor.OmittedExpression?.(node, context); break;
    case SyntaxKind.OptionalType: visitor.OptionalTypeNode?.(node, context); break;
    case SyntaxKind.Parameter: visitor.ParameterDeclaration?.(node, context); break;
    case SyntaxKind.ParenthesizedExpression: visitor.ParenthesizedExpression?.(node, context); break;
    case SyntaxKind.ParenthesizedType: visitor.ParenthesizedTypeNode?.(node, context); break;
    case SyntaxKind.PartiallyEmittedExpression: visitor.PartiallyEmittedExpression?.(node, context); break;
    case SyntaxKind.PostfixUnaryExpression: visitor.PostfixUnaryExpression?.(node, context); break;
    case SyntaxKind.PrefixUnaryExpression: visitor.PrefixUnaryExpression?.(node, context); break;
    case SyntaxKind.PrivateIdentifier: visitor.PrivateIdentifier?.(node, context); break;
    case SyntaxKind.PropertyAccessExpression: visitor.PropertyAccessExpression?.(node, context); break;
    case SyntaxKind.PropertyAssignment: visitor.PropertyAssignment?.(node, context); break;
    case SyntaxKind.PropertyDeclaration: visitor.PropertyDeclaration?.(node, context); break;
    case SyntaxKind.PropertySignature: visitor.PropertySignature?.(node, context); break;
    case SyntaxKind.QualifiedName: visitor.QualifiedName?.(node, context); break;
    case SyntaxKind.RegularExpressionLiteral: visitor.RegularExpressionLiteral?.(node, context); break;
    case SyntaxKind.RestType: visitor.RestTypeNode?.(node, context); break;
    case SyntaxKind.ReturnStatement: visitor.ReturnStatement?.(node, context); break;
    case SyntaxKind.SatisfiesExpression: visitor.SatisfiesExpression?.(node, context); break;
    case SyntaxKind.SemicolonClassElement: visitor.SemicolonClassElement?.(node, context); break;
    case SyntaxKind.SetAccessor: visitor.SetAccessorDeclaration?.(node, context); break;
    case SyntaxKind.ShorthandPropertyAssignment: visitor.ShorthandPropertyAssignment?.(node, context); break;
    case SyntaxKind.SourceFile: visitor.SourceFile?.(node, context); break;
    case SyntaxKind.SpreadAssignment: visitor.SpreadAssignment?.(node, context); break;
    case SyntaxKind.SpreadElement: visitor.SpreadElement?.(node, context); break;
    case SyntaxKind.StringLiteral: visitor.StringLiteral?.(node, context); break;
    case SyntaxKind.SuperKeyword: visitor.SuperExpression?.(node, context); break;
    case SyntaxKind.SwitchStatement: visitor.SwitchStatement?.(node, context); break;
    case SyntaxKind.SyntheticExpression: visitor.SyntheticExpression?.(node, context); break;
    case SyntaxKind.TaggedTemplateExpression: visitor.TaggedTemplateExpression?.(node, context); break;
    case SyntaxKind.TemplateExpression: visitor.TemplateExpression?.(node, context); break;
    case SyntaxKind.TemplateHead: visitor.TemplateHead?.(node, context); break;
    case SyntaxKind.TemplateLiteralType: visitor.TemplateLiteralTypeNode?.(node, context); break;
    case SyntaxKind.TemplateLiteralTypeSpan: visitor.TemplateLiteralTypeSpan?.(node, context); break;
    case SyntaxKind.TemplateMiddle: visitor.TemplateMiddle?.(node, context); break;
    case SyntaxKind.TemplateSpan: visitor.TemplateSpan?.(node, context); break;
    case SyntaxKind.TemplateTail: visitor.TemplateTail?.(node, context); break;
    case SyntaxKind.ThisKeyword: visitor.ThisExpression?.(node, context); break;
    case SyntaxKind.ThisType: visitor.ThisTypeNode?.(node, context); break;
    case SyntaxKind.ThrowStatement: visitor.ThrowStatement?.(node, context); break;
    case SyntaxKind.TrueKeyword: visitor.TrueLiteral?.(node, context); break;
    case SyntaxKind.TryStatement: visitor.TryStatement?.(node, context); break;
    case SyntaxKind.TupleType: visitor.TupleTypeNode?.(node, context); break;
    case SyntaxKind.TypeAliasDeclaration: visitor.TypeAliasDeclaration?.(node, context); break;
    case SyntaxKind.TypeAssertionExpression: visitor.TypeAssertion?.(node, context); break;
    case SyntaxKind.TypeLiteral: visitor.TypeLiteralNode?.(node, context); break;
    case SyntaxKind.TypeOfExpression: visitor.TypeOfExpression?.(node, context); break;
    case SyntaxKind.TypeOperator: visitor.TypeOperatorNode?.(node, context); break;
    case SyntaxKind.TypeParameter: visitor.TypeParameterDeclaration?.(node, context); break;
    case SyntaxKind.TypePredicate: visitor.TypePredicateNode?.(node, context); break;
    case SyntaxKind.TypeQuery: visitor.TypeQueryNode?.(node, context); break;
    case SyntaxKind.TypeReference: visitor.TypeReferenceNode?.(node, context); break;
    case SyntaxKind.UnionType: visitor.UnionTypeNode?.(node, context); break;
    case SyntaxKind.VariableDeclaration: visitor.VariableDeclaration?.(node, context); break;
    case SyntaxKind.VariableDeclarationList: visitor.VariableDeclarationList?.(node, context); break;
    case SyntaxKind.VariableStatement: visitor.VariableStatement?.(node, context); break;
    case SyntaxKind.VoidExpression: visitor.VoidExpression?.(node, context); break;
    case SyntaxKind.WhileStatement: visitor.WhileStatement?.(node, context); break;
    case SyntaxKind.WithStatement: visitor.WithStatement?.(node, context); break;
    case SyntaxKind.YieldExpression: visitor.YieldExpression?.(node, context); break;
  }
  node.forEachChild(child => visit(child as any, visitor, context));
}
