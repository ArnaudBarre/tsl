# type-lint [![npm](https://img.shields.io/npm/v/@arnaud-barre/type-lint)](https://www.npmjs.com/package/@arnaud-barre/type-lint)

Ongoing work for a modern TypeScript linter

## Features

- Run type-aware rules faster than ESLint
- Type safe config with custom rules in TypeScript
- No [IDE caching issue](https://typescript-eslint.io/troubleshooting/faqs/general/#changes-to-one-file-are-not-reflected-when-linting-other-files-in-my-ide)

## Type-aware linting

Most lint rules only rely on the structure (AST) to detect issues. On top of that, type-aware linting leverage type information, such as the types of variables or return values, to detect new issues. Here are two of the most common issues that type-aware linting can detect:

```ts
async function foo() {
  try {
    doAsyncWork(); // <- Missing await
  } catch {
    // This will never run, even if doAsyncWork() throws
    return getDefault();
  }
}
```

```ts
type User = { firstName: string | null };

function greet(user: User) {
  console.log(`Hello ${user.firstName}`);
}

greet({ firstName: null }); // logs "Hello null"
```

To know if you are using type-aware linting in ESLint, see if `@typescript-eslint/parser` is installed and if you have `project` or `projectService` in `languageOptions.parserOptions` in your config.

## Philosophy

type-lint is like an extension of tsc, where you can create rules that generates reports that are displayed alongside the built-in type errors. No file resolution, no files/includes glob, no parsing: simply take all the files from a TS config and run the rules on the AST generated by TS.

This means that editor support can be provided though a compiler plugin and that, like TS errors, there is no auto-fix and only suggestions are available.

I don't think this scale well to hundreds of rules. Most lint rules don't require type information and tools written in Rust like [Oxlint](https://oxc.rs/docs/guide/usage/linter.html) or [Biome](https://biomejs.dev/) are really well suited for this.

### What about tsgo?

I still have to investigate how the language service integration will work with inter-process communication. Probably most of the main rules will have to be ported to Go to be efficient, but this having them ported to the TS AST is still a necessary useful step.

## Installation

```bash
bun add @arnaud-barre/type-lint
```

### Add a configuration

Add a `type-lint.config.ts` file to your project root. If you don't have one, all core rules are enabled.

You can either enable all core rules and disable some of them or update options if needed

```ts
import { core, defineConfig } from "@arnaud-barre/type-lint";

export default defineConfig({
  rules: [
    ...core.all({
      noUnnecessaryBooleanLiteralCompare: "off",
      switchExhaustivenessCheck: {
        considerDefaultExhaustiveForUnions: true,
      },
    }),
  ],
});
```

Or pick only the rules you want to enable.

```ts
import { core, defineConfig } from "@arnaud-barre/type-lint";

export default defineConfig({
  rules: [
    core.noFloatingPromises(),
    core.noForInArray(),
    core.preferOptionalChain(),
    core.switchExhaustivenessCheck({
      considerDefaultExhaustiveForUnions: true,
    }),
  ],
});
```

### Add the TypeScript plugin

Instead of developing multiple plugins for each IDE, type-lint provides a compiler plugin that can be used to display diagnostics in the editor and provide suggestions.

In your `tsconfig.json` add the following:

```json
{
  "compilerOptions": {
    "plugins": [{ "name": "@arnaud-barre/type-lint/plugin" }]
  }
}
```

> [!IMPORTANT]
> If you use VS Code, you need to run the "TypeScript: Select TypeScript Version" command and choose "Use Workspace Version".

### Update your scripts to run the linter

To avoid parsing and typechecking twice your codebase, type-lint run first tsc via the javascript API and then run rules on the TS AST.

```diff
{
  "scripts": {
-    "typecheck": "tsc"
+    "typecheck": "type-lint"
  }
}
```

#### Can I use it without the tsc wrapper?

Yes, you can run `type-lint --lint-only` directly. But if you use rules that request type information for a lot of nodes, this can be very inefficient with you run one after the other. As an example, running on my work codebase (~1k TS files), `tsc` take 17s, `type-lint --lint-only` take 17s, and `type-lint` (doing both) take 21s.

### Update your CI

```diff
-  - run: bun tsc
+  - run: bun type-lint
```

### Run for another tsconfig

```sh
type-lint -p tsconfig.test.json
type-lint --project tsconfig.test.json
```

## Configuration

### ignore

Everything in node_modules is ignored by default. If you want to ignore generated code, you can use the `ignore` option. The current implementation is simply `ignore.some((i) => path.includes(i))`. By design, files that are excluded in the TS config will not be linted.

```ts
defineConfig({
  ignore: ["src/generated/"],
});
```

### diagnosticCategory

To differentiate type-lint reports from TS errors, type-lint diagnostics are reported by default as warnings. If you prefer having only red squiggles, you can set the `diagnosticCategory` option to `"error"`.

```ts
defineConfig({
  diagnosticCategory: "error",
});
```

### overrides

If for some subset of files you want to enable or disable rules, you can use the `overrides` option like this:

```ts
defineConfig({
  overrides: [
    {
      files: [".server.ts"],
      disabled: ["core/dotNotation"],
      rules: [
        core.switchExhaustivenessCheck({ requireDefaultForNonUnion: true }),
      ],
    },
  ],
});
```

Like the ignore option, the `files` option test for inclusion against the file path.

Redeclared rules (identical name) completely replace the "base" rule, there is no merging of options.

## Custom rules

Writing custom rules is part of the core value of type-lint.

Rules run on the TS AST, which is less known than ESTree but allows to query type information for a given node with `context.checker.getTypeAtLocation(node)`. Use [ast-explorer.dev](https://ast-explorer.dev/#eNo9zEEKwjAQheGrxLdSKG5ctV5AcO9qNiEdQmSYCUlVpPTuTSl0+72fN0Mw4O2/voaS8oQOucH0z3xAaBBMqwlfxeKZ8GARcz8rMp4Ilztpy6xlM6lzBPEaPz7yi0tNpoTB9X23b/vtM+m48Y10wbIChCAraw==) to explore the AST.

By default, the TS AST is, funny enough, poorly typed. That's why the linter ships rewritten AST types that you can import and allow for type narrowing and exhaustive switches.

To help build rules, a few common utils are available on `context.utils`, and `context.checker` is overridden with some type changes. If you need to pass the checker to another library that expect the builtin TypeChecker type, like [ts-api-utils](https://github.com/JoshuaKGoldberg/ts-api-utils), you can use `context.rawChecker`.

```ts
import { type AST, core, defineConfig } from "@arnaud-barre/type-lint";
import { SyntaxKind } from "typescript";

export default defineConfig({
  rules: [
    ...core.all(),
    {
      name: "org/useLogger",
      visitor: {
        CallExpression(node, context) {
          if (
            node.expression.kind === SyntaxKind.PropertyAccessExpression
            && node.expression.expression.kind === SyntaxKind.Identifier
            && node.expression.expression.text === "console"
          ) {
            node.expression.expression satisfies AST.Identifier;
            context.report({ message: "Use logger instead", node });
          }
        },
      },
    },
  ],
});
```

## Core rules

Currently, the list of core rules are the type-aware lint rules I use from TS-ESLint. If you think more rules should be added, please open an issue, but to reduce the surface, only non-styling type-aware rules will be accepted. Here is the list of [TS-ESLint type aware rules](https://typescript-eslint.io/rules/?=typeInformation) with their status:

- await-thenable: ‚úÖ Implemented
- consistent-return: üõë Implementation not planned, you can use `noImplicitReturns` compilerOption
- consistent-type-exports: üõë Implementation not planned, you can use `verbatimModuleSyntax` compilerOption
- dot-notation: ‚úÖ Implemented without options
- naming-convention: Styling is out of core
- no-array-delete: ‚úÖ Implemented
- no-base-to-string: ‚úÖ Implemented, only `String()`, `.to(Locale)String()` and `.join()` are checked, see `restrict-plus-operands` and `restrict-template-expressions` for other checks
- no-confusing-void-expression: ‚úÖ Implemented
- no-deprecated: ‚ùå Not implemented
- no-duplicate-type-constituents: üóëÔ∏è Merged with `no-redundant-type-constituents`
- no-floating-promises: ‚úÖ Implemented, allowList is named based only
- no-for-in-array: ‚úÖ Implemented
- no-implied-eval: ‚úÖ Implemented, do not check for global shadowing
- no-meaningless-void-operator: ‚úÖ Implemented
- no-misused-promises: ‚úÖ Implemented
- no-misused-spread: ‚úÖ Implemented, no allow option
- no-mixed-enums: üõë TS only concepts are out of core
- no-redundant-type-constituents: ‚úÖ Implemented and smarter thanks to `checker.isTypeAssignableTo`
- no-unnecessary-boolean-literal-compare: ‚úÖ Implemented
- no-unnecessary-condition: ‚úÖ Implemented
- no-unnecessary-qualifier: TS only concepts are out of core
- no-unnecessary-template-expression: ‚úÖ Implemented
- no-unnecessary-type-arguments: ‚úÖ Implemented
- no-unnecessary-type-assertion: ‚úÖ Implemented
- no-unnecessary-type-conversion: ‚úÖ Implemented
- no-unnecessary-type-parameters: ‚ùå Not implemented, IMO report too many legitimate cases
- no-unsafe-argument: ‚ùå Not implemented, too noisy for me
- no-unsafe-assignment: ‚ùå Not implemented, too noisy for me
- no-unsafe-call: ‚ùå Not implemented, too noisy for me
- no-unsafe-enum-comparison: üõë TS only concepts are out of core
- no-unsafe-member-access: ‚ùå Not implemented, too noisy for me
- no-unsafe-return: ‚ùå Not implemented, too noisy for me
- no-unsafe-type-assertion: ‚ùå Not implemented, too noisy for me
- no-unsafe-unary-minus: ‚úÖ Implemented
- non-nullable-type-assertion-style: ‚úÖ Implemented
- only-throw-error: ‚úÖ Implemented, allow options is named based only
- prefer-destructuring: Styling is out of core
- prefer-find: ‚úÖ Implemented
- prefer-includes: ‚úÖ Implemented, without `/baz/.test(a)`, it requires regex parsing and can be achieved without type information
- prefer-nullish-coalescing: ‚úÖ Implemented
- prefer-optional-chain: ‚úÖ Implemented
- prefer-promise-reject-errors: üõë Implementation not planned, can be achieved with global types instead
- prefer-readonly: ‚ùå Not implemented, too OOP for me
- prefer-readonly-parameter-types: üõë Implementation not planned, it would better to check that function parameters are never mutated instead
- prefer-reduce-type-parameter: ‚úÖ Implemented,
- prefer-regexp-exec: üõë Small runtime optimization are out of core
- prefer-return-this-type: ‚úÖ Implemented
- prefer-string-starts-ends-with: ‚úÖ Implemented
- promise-function-async: ‚ùå Not implemented
- related-getter-setter-pairs: ‚ùå Not implemented, too OOP for me
- require-array-sort-compare: ‚ùå Not implemented
- require-await: üõë Implementation not planned, type information to handle async generators, which is a niche case
- restrict-plus-operands: ‚úÖ Implemented with stricter defaults, always lint assignment
- restrict-template-expressions: ‚úÖ Implemented, with stricter defaults
- return-await: ‚úÖ Implemented, only support always, remove unneeded await handled by await-thenable
- strict-boolean-expressions: ‚ùå Not implemented
- switch-exhaustiveness-check: ‚úÖ Implemented, missing no default comment #10218
- unbound-method: ‚ùå Not implemented, too OOP for me
- use-unknown-in-catch-callback-variable: üõë Implementation not planned, you can use global types instead

## Create sharable rules

This is a work in progress, but if you are interested into publishing rules, you can use `defineRule` and `createRulesSet` that are used for the core rules.
